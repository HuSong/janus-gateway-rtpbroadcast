/*! \file   janus_rtpbroadcast.c
 * \author Lorenzo Miniero <lorenzo@meetecho.com>
 * \copyright GNU General Public License v3
 * \brief  Janus Streaming plugin
 * \details  This is a streaming plugin for Janus, allowing WebRTC peers
 * to watch/listen to pre-recorded files or media generated by another tool.
 * Specifically, the plugin currently supports three different type of streams:
 *
 * -# on-demand streaming of pre-recorded media files (different
 * streaming context for each peer);
 * -# live streaming of pre-recorded media files (shared streaming
 * context for all peers attached to the stream);
 * -# live streaming of media generated by another tool (shared
 * streaming context for all peers attached to the stream).
 *
 * For what concerns types 1. and 2., considering the proof of concept
 * nature of the implementation the only pre-recorded media files
 * that the plugins supports right now are raw mu-Law and a-Law files:
 * support is of course planned for other additional widespread formats
 * as well.
 *
 * For what concerns type 3., instead, the plugin is configured
 * to listen on a couple of ports for RTP: this means that the plugin
 * is implemented to receive RTP on those ports and relay them to all
 * peers attached to that stream. Any tool that can generate audio/video
 * RTP streams and specify a destination is good for the purpose: the
 * examples section contains samples that make use of GStreamer (http://gstreamer.freedesktop.org/)
 * but other tools like FFmpeg (http://www.ffmpeg.org/), LibAV (http://libav.org/)
 * or others are fine as well. This makes it really easy to capture and
 * encode whatever you want using your favourite tool, and then have it
 * transparently broadcasted via WebRTC using Janus.
 *
 * Streams to make available are listed in the plugin configuration file.
 * A pre-filled configuration file is provided in \c conf/janus.plugin.streaming.cfg
 * and includes a stream of every type.
 *
 * To add more streams or modify the existing ones, you can use the following
 * syntax:
 *
 * \verbatim
[stream-name]
type = rtp|live|ondemand|rtsp
       rtp = stream originated by an external tool (e.g., gstreamer or
             ffmpeg) and sent to the plugin via RTP
       live = local file streamed live to multiple listeners
              (multiple listeners = same streaming context)
       ondemand = local file streamed on-demand to a single listener
                  (multiple listeners = different streaming contexts)
       rtsp = stream originated by an external RTSP feed (only
              available if libcurl support was compiled)
id = <unique numeric ID>
description = This is my awesome stream
is_private = yes|no (private streams don't appear when you do a 'list' request)
filename = path to the local file to stream (only for live/ondemand)
secret = <optional password needed for manipulating (e.g., destroying
		or enabling/disabling) the stream>
pin = <optional password needed for watching the stream>
audio = yes|no (do/don't stream audio)
video = yes|no (do/don't stream video)
   The following options are only valid for the 'rtp' type:
audioport = local port for receiving audio frames
audiomcast = multicast group port for receiving audio frames, if any
audiopt = <audio RTP payload type> (e.g., 111)
audiortpmap = RTP map of the audio codec (e.g., opus/48000/2)
audiofmtp = Codec specific parameters, if any
videoport = local port for receiving video frames (only for rtp)
videomcast = multicast group port for receiving video frames, if any
videopt = <video RTP payload type> (e.g., 100)
videortpmap = RTP map of the video codec (e.g., VP8/90000)
videofmtp = Codec specific parameters, if any
   The following options are only valid for the 'rstp' type:
url = RTSP stream URL (only if type=rtsp)
\endverbatim
 *
 * \section streamapi Streaming API
 *
 * The Streaming API supports several requests, some of which are
 * synchronous and some asynchronous. There are some situations, though,
 * (invalid JSON, invalid request) which will always result in a
 * synchronous error response even for asynchronous requests.
 *
 * \c list , \c create , \c destroy , \c recording , \c enable and
 * \c disable are synchronous requests, which means you'll
 * get a response directly within the context of the transaction. \c list
 * lists all the available streams; \c create allows you to create a new
 * mountpoint dynamically, as an alternative to using the configuration
 * file; \c destroy removes a mountpoint and destroys it; \c recording
 * instructs the plugin on whether or not a live RTP stream should be
 * recorded while it's broadcasted; \c enable and \c disable respectively
 * enable and disable a mountpoint, that is decide whether or not a
 * mountpoint should be available to users without destroying it.
 *
 * The \c watch , \c start , \c pause , \c switch and \c stop requests
 * instead are all asynchronous, which means you'll get a notification
 * about their success or failure in an event. \c watch asks the plugin
 * to prepare the playout of one of the available streams; \c start
 * starts the actual playout; \c pause allows you to pause a playout
 * without tearing down the PeerConnection; \c switch allows you to
 * switch to a different mountpoint of the same kind (note: only live
 * RTP mountpoints supported as of now) without having to stop and watch
 * the new one; \c stop stops the playout and tears the PeerConnection
 * down.
 *
 * Actual API docs: TBD.
 *
 * \ingroup plugins
 * \ref plugins
 */

#include "plugins/plugin.h"

#include <jansson.h>
#include <errno.h>
#include <sys/poll.h>
#include <sys/time.h>
#include <netinet/ip.h>
#include <netinet/udp.h>

#include "debug.h"
#include "apierror.h"
#include "config.h"
#include "mutex.h"
#include "rtp.h"
#include "rtcp.h"
#include "record.h"
#include "utils.h"


/* Plugin information */
#define JANUS_RTPBROADCAST_VERSION			5
#define JANUS_RTPBROADCAST_VERSION_STRING	"0.0.5"
#define JANUS_RTPBROADCAST_DESCRIPTION		"This is a streaming plugin for Janus, allowing WebRTC peers to watch/listen to pre-recorded files or media generated by gstreamer."
#define JANUS_RTPBROADCAST_NAME			"JANUS CM video plugin"
#define JANUS_RTPBROADCAST_AUTHOR			"Meetecho s.r.l."
#define JANUS_RTPBROADCAST_PACKAGE			"janus.plugin.cm.rtpbroadcast"

/* Plugin methods */
janus_plugin *create(void);
int janus_rtpbroadcast_init(janus_callbacks *callback, const char *config_path);
void janus_rtpbroadcast_destroy(void);
int janus_rtpbroadcast_get_api_compatibility(void);
int janus_rtpbroadcast_get_version(void);
const char *janus_rtpbroadcast_get_version_string(void);
const char *janus_rtpbroadcast_get_description(void);
const char *janus_rtpbroadcast_get_name(void);
const char *janus_rtpbroadcast_get_author(void);
const char *janus_rtpbroadcast_get_package(void);
void janus_rtpbroadcast_create_session(janus_plugin_session *handle, int *error);
struct janus_plugin_result *janus_rtpbroadcast_handle_message(janus_plugin_session *handle, char *transaction, char *message, char *sdp_type, char *sdp);
void janus_rtpbroadcast_setup_media(janus_plugin_session *handle);
void janus_rtpbroadcast_incoming_rtp(janus_plugin_session *handle, int video, char *buf, int len);
void janus_rtpbroadcast_incoming_rtcp(janus_plugin_session *handle, int video, char *buf, int len);
void janus_rtpbroadcast_hangup_media(janus_plugin_session *handle);
void janus_rtpbroadcast_destroy_session(janus_plugin_session *handle, int *error);
char *janus_rtpbroadcast_query_session(janus_plugin_session *handle);

/* Plugin setup */
static janus_plugin janus_rtpbroadcast_plugin =
	JANUS_PLUGIN_INIT (
		.init = janus_rtpbroadcast_init,
		.destroy = janus_rtpbroadcast_destroy,

		.get_api_compatibility = janus_rtpbroadcast_get_api_compatibility,
		.get_version = janus_rtpbroadcast_get_version,
		.get_version_string = janus_rtpbroadcast_get_version_string,
		.get_description = janus_rtpbroadcast_get_description,
		.get_name = janus_rtpbroadcast_get_name,
		.get_author = janus_rtpbroadcast_get_author,
		.get_package = janus_rtpbroadcast_get_package,

		.create_session = janus_rtpbroadcast_create_session,
		.handle_message = janus_rtpbroadcast_handle_message,
		.setup_media = janus_rtpbroadcast_setup_media,
		.incoming_rtp = janus_rtpbroadcast_incoming_rtp,
		.incoming_rtcp = janus_rtpbroadcast_incoming_rtcp,
		.hangup_media = janus_rtpbroadcast_hangup_media,
		.destroy_session = janus_rtpbroadcast_destroy_session,
		.query_session = janus_rtpbroadcast_query_session,
	);

/* Plugin creator */
janus_plugin *create(void) {
	JANUS_LOG(LOG_VERB, "%s created!\n", JANUS_RTPBROADCAST_NAME);
	return &janus_rtpbroadcast_plugin;
}


/* Useful stuff */
static volatile gint initialized = 0, stopping = 0;
static janus_callbacks *gateway = NULL;
static GThread *handler_thread;
static GThread *watchdog;
static void *janus_rtpbroadcast_handler(void *data);
static void janus_rtpbroadcast_relay_rtp_packet(gpointer data, gpointer user_data);
static void *janus_rtpbroadcast_relay_thread(void *data);

/* Helper to remove insane code duplication everywhere
 	 Sample illustrating use:
			something things[] = { X, Y, Z };
			_foreach(i, things) {
				print(things[i]);
			}

			Note, iterator variable exported in the current scope;
			*/
#define _foreach(var, container) size_t var; for (var = 0; var < sizeof(container)/sizeof(container[0]); i++)

/* To remove unnecessary duplication all over, all things are arrays of 2 now
 	 i.e. instead of audio_port you have port[AUDIO]
	 As a bonus, av_names[AUDIO] is "audio" string and so on
*/
#define AUDIO 0
#define VIDEO 1
#define AV		2
const char *av_names[] = { "audio", "video" };

typedef struct janus_rtpbroadcast_codecs {
	gint pt[AV];
	char *rtpmap[AV];
	char *fmtp[AV];
} janus_rtpbroadcast_codecs;

#define STAT_UPDATE_DELAY 1000000
typedef struct janus_rtpbroadcast_stats {
	gdouble min;
	gdouble max;
	gdouble cur;
	gdouble avg;

	guint64 start_usec;
	guint64 last_avg_usec;
	guint64 bytes_since_start;
	guint64 bytes_since_last_avg;

	janus_mutex stat_mutex;
} janus_rtpbroadcast_stats;
static void janus_rtpbroadcast_stats_restart(janus_rtpbroadcast_stats *);
static void janus_rtpbroadcast_stats_update(janus_rtpbroadcast_stats *, int);

typedef struct janus_rtpbroadcast_mountpoint {
	char *id;
	char *name;
	char *description;

	gboolean enabled;

	gboolean recorded; 		/* Only sources[0] is recorded by default */
	janus_recorder *rc[AV];	/* The Janus recorder instance for this mountpoint's audio/video, if enabled */

	GArray *sources; // of type janus_rtpbroadcast_rtp_source*

	GList/*<unowned janus_rtpbroadcast_session>*/ *listeners;
	gint64 destroyed;
	janus_mutex mutex;
} janus_rtpbroadcast_mountpoint;
GHashTable *mountpoints;
static GList *old_mountpoints;
janus_mutex mountpoints_mutex;

typedef struct janus_rtpbroadcast_rtp_source {
	gboolean active;
	guint port[AV];
	in_addr_t mcast[AV];
	int fd[AV];
	janus_rtpbroadcast_codecs codecs;
	janus_rtpbroadcast_stats stats;
	janus_rtpbroadcast_mountpoint *parent;
} janus_rtpbroadcast_rtp_source;

/* The idea is, keep pointers to sources in hash table and keep track of
	 available ports in the shuffled list. When a port is fred, it is inserted
	 at a random poisition back in the list, thus the computatonally intensive
	 operations are carried at startup and at source destruction only
	 */
static struct {
	GHashTable *used_ports;
	GList *free_ports;
	janus_mutex used_ports_mutex;
	guint ports_available;					/* GList doesn't keep track of size */
} port_manager;
static void janus_rtpbroadcast_port_manager_init();
static guint janus_rtpbroadcast_port_manager_assign(gpointer);
static void janus_rtpbroadcast_port_manager_free(guint);
static void janus_rtpbroadcast_port_manager_destroy();

static void janus_rtpbroadcast_mountpoint_free(janus_rtpbroadcast_mountpoint *mp);

/* Helper to create an RTP live source (e.g., from gstreamer/ffmpeg/vlc/etc.) */
typedef struct janus_rtpbroadcast_rtp_source_request {
	char *mcast[AV];
	uint8_t codec[AV];
	char *rtpmap[AV];
	char *fmtp[AV];
} janus_rtpbroadcast_rtp_source_request;

typedef struct janus_rtpbroadcast_rtp_relay_thread_data {
	janus_rtpbroadcast_mountpoint *mp;
	guint i;
} janus_rtpbroadcast_rtp_relay_thread_data;

janus_rtpbroadcast_mountpoint *janus_rtpbroadcast_create_rtp_source(
		char* id, char *name, char *desc,
		GArray *requests);

typedef struct janus_rtpbroadcast_message {
	janus_plugin_session *handle;
	char *transaction;
	json_t *message;
	char *sdp_type;
	char *sdp;
} janus_rtpbroadcast_message;
static GAsyncQueue *messages = NULL;

void janus_rtpbroadcast_message_free(janus_rtpbroadcast_message *msg);
void janus_rtpbroadcast_message_free(janus_rtpbroadcast_message *msg) {
	if(!msg)
		return;

	msg->handle = NULL;

	g_free(msg->transaction);
	msg->transaction = NULL;
	if(msg->message)
		json_decref(msg->message);
	msg->message = NULL;
	g_free(msg->sdp_type);
	msg->sdp_type = NULL;
	g_free(msg->sdp);
	msg->sdp = NULL;

	g_free(msg);
}


typedef struct janus_rtpbroadcast_context {
	/* Needed to fix seq and ts in case of stream switching */
	uint32_t last_ssrc[AV], last_ts[AV], base_ts[AV], base_ts_prev[AV];
	uint16_t last_seq[AV], base_seq[AV], base_seq_prev[AV];
} janus_rtpbroadcast_context;

typedef struct janus_rtpbroadcast_session {
	janus_plugin_session *handle;
	janus_rtpbroadcast_mountpoint *mountpoint;
	gboolean started;
	gboolean paused;
	janus_rtpbroadcast_context context;
	gboolean stopping;
	volatile gint hangingup;
	gint64 destroyed;	/* Time at which this session was marked as destroyed */
} janus_rtpbroadcast_session;
static GHashTable *sessions;
static GList *old_sessions;
static janus_mutex sessions_mutex;

/* Packets we get from gstreamer and relay */
typedef struct janus_rtpbroadcast_rtp_relay_packet {
	rtp_header *data;
	gint length;
	gint is_video;
	uint32_t timestamp;
	uint16_t seq_number;
} janus_rtpbroadcast_rtp_relay_packet;


/* Error codes */
#define JANUS_RTPBROADCAST_ERROR_NO_MESSAGE			450
#define JANUS_RTPBROADCAST_ERROR_INVALID_JSON			451
#define JANUS_RTPBROADCAST_ERROR_INVALID_REQUEST		452
#define JANUS_RTPBROADCAST_ERROR_MISSING_ELEMENT		453
#define JANUS_RTPBROADCAST_ERROR_INVALID_ELEMENT		454
#define JANUS_RTPBROADCAST_ERROR_NO_SUCH_MOUNTPOINT	455
#define JANUS_RTPBROADCAST_ERROR_CANT_CREATE			456
#define JANUS_RTPBROADCAST_ERROR_UNAUTHORIZED			457
#define JANUS_RTPBROADCAST_ERROR_CANT_SWITCH			458
#define JANUS_RTPBROADCAST_ERROR_UNKNOWN_ERROR			470


/* Streaming watchdog/garbage collector (sort of) */
void *janus_rtpbroadcast_watchdog(void *data);
void *janus_rtpbroadcast_watchdog(void *data) {
	JANUS_LOG(LOG_INFO, "Streaming watchdog started\n");
	gint64 now = 0;
	while(g_atomic_int_get(&initialized) && !g_atomic_int_get(&stopping)) {
		janus_mutex_lock(&sessions_mutex);
		/* Iterate on all the sessions */
		now = janus_get_monotonic_time();
		if(old_sessions != NULL) {
			GList *sl = old_sessions;
			JANUS_LOG(LOG_HUGE, "Checking %d old Streaming sessions...\n", g_list_length(old_sessions));
			while(sl) {
				janus_rtpbroadcast_session *session = (janus_rtpbroadcast_session *)sl->data;
				if(!session) {
					sl = sl->next;
					continue;
				}
				if(now-session->destroyed >= 5*G_USEC_PER_SEC) {
					/* We're lazy and actually get rid of the stuff only after a few seconds */
					JANUS_LOG(LOG_VERB, "Freeing old Streaming session\n");
					GList *rm = sl->next;
					old_sessions = g_list_delete_link(old_sessions, sl);
					sl = rm;
					session->handle = NULL;
					g_free(session);
					session = NULL;
					continue;
				}
				sl = sl->next;
			}
		}
		janus_mutex_unlock(&sessions_mutex);
		janus_mutex_lock(&mountpoints_mutex);
		/* Iterate on all the mountpoints */
		if(old_mountpoints != NULL) {
			GList *sl = old_mountpoints;
			JANUS_LOG(LOG_HUGE, "Checking %d old Streaming mountpoints...\n", g_list_length(old_mountpoints));
			while(sl) {
				janus_rtpbroadcast_mountpoint *mountpoint = (janus_rtpbroadcast_mountpoint *)sl->data;
				if(!mountpoint) {
					sl = sl->next;
					continue;
				}
				if(now-mountpoint->destroyed >= 5*G_USEC_PER_SEC) {
					/* We're lazy and actually get rid of the stuff only after a few seconds */
					JANUS_LOG(LOG_VERB, "Freeing old Streaming mountpoint\n");
					GList *rm = sl->next;
					old_mountpoints = g_list_delete_link(old_mountpoints, sl);
					sl = rm;
					janus_rtpbroadcast_mountpoint_free(mountpoint);
					mountpoint = NULL;
					continue;
				}
				sl = sl->next;
			}
		}
		janus_mutex_unlock(&mountpoints_mutex);
		g_usleep(500000);
	}
	JANUS_LOG(LOG_INFO, "Streaming watchdog stopped\n");
	return NULL;
}


/* Plugin implementation */
int janus_rtpbroadcast_init(janus_callbacks *callback, const char *config_path) {
	if(g_atomic_int_get(&stopping)) {
		/* Still stopping from before */
		return -1;
	}
	if(callback == NULL || config_path == NULL) {
		/* Invalid arguments */
		return -1;
	}

	/* Read configuration */
	char filename[255];
	g_snprintf(filename, 255, "%s/%s.cfg", config_path, JANUS_RTPBROADCAST_PACKAGE);
	JANUS_LOG(LOG_VERB, "Configuration file: %s\n", filename);
	janus_config *config = janus_config_parse(filename);
	if(config != NULL)
		janus_config_print(config);

	guint minport = 8000, maxport = 12000;

	mountpoints = g_hash_table_new_full(
		g_str_hash,	 /* Hashing func */
		g_str_equal, /* Key comparator */
		g_free,			 /* Key destructor */
		NULL);			 /* Value destructor, we don't want this done automatically */
	janus_mutex_init(&mountpoints_mutex);
	/* Parse configuration to populate the mountpoints */
	if(config != NULL) {
		const char *inames [] = { "minport", "maxport" };
		guint *ivars [] = { &minport, &maxport };
		guint i;

		for (i = 0; i < sizeof(ivars)/sizeof(guint*); i++) {
			janus_config_item *itm = janus_config_get_item_drilldown(config, "general", inames[i]);
			if (itm && itm->value) {
				guint res = g_ascii_strtoull(itm->value, NULL, 10);
				if (res != 0)
					*ivars[i] = res;
			}
		}

		if(minport > maxport) {
			g_atomic_int_set(&initialized, 0);
			JANUS_LOG(LOG_ERR, "Configuration error: minport %d is bigger than maxport %d\n", minport, maxport);
			return -1;
		}

		/* Done */
		janus_config_destroy(config);
		config = NULL;
	}
	janus_rtpbroadcast_port_manager_init(minport, maxport);

	/* Not showing anything, no mountpoint configured at startup */
	sessions = g_hash_table_new(NULL, NULL);
	janus_mutex_init(&sessions_mutex);
	messages = g_async_queue_new_full((GDestroyNotify) janus_rtpbroadcast_message_free);
	/* This is the callback we'll need to invoke to contact the gateway */
	gateway = callback;
	g_atomic_int_set(&initialized, 1);

	GError *error = NULL;
	/* Start the sessions watchdog */
	watchdog = g_thread_try_new("rtpbroadcast watchdog", &janus_rtpbroadcast_watchdog, NULL, &error);
	if(!watchdog) {
		g_atomic_int_set(&initialized, 0);
		JANUS_LOG(LOG_ERR, "Got error %d (%s) trying to launch the RTP broadcast watchdog thread...\n", error->code, error->message ? error->message : "??");
		return -1;
	}
	/* Launch the thread that will handle incoming messages */
	handler_thread = g_thread_try_new("janus rtpbroadcast handler", janus_rtpbroadcast_handler, NULL, &error);
	if(error != NULL) {
		g_atomic_int_set(&initialized, 0);
		JANUS_LOG(LOG_ERR, "Got error %d (%s) trying to launch the RTP broadcast handler thread...\n", error->code, error->message ? error->message : "??");
		return -1;
	}
	JANUS_LOG(LOG_INFO, "%s initialized!\n", JANUS_RTPBROADCAST_NAME);
	return 0;
}

void janus_rtpbroadcast_destroy(void) {
	if(!g_atomic_int_get(&initialized))
		return;
	g_atomic_int_set(&stopping, 1);

	if(handler_thread != NULL) {
		g_thread_join(handler_thread);
		handler_thread = NULL;
	}

	/* Remove all mountpoints */
	janus_mutex_unlock(&mountpoints_mutex);
	GHashTableIter iter;
	gpointer value;
	g_hash_table_iter_init(&iter, mountpoints);
	while (g_hash_table_iter_next(&iter, NULL, &value)) {
		janus_rtpbroadcast_mountpoint *mp = value;
		if(!mp->destroyed) {
			mp->destroyed = janus_get_monotonic_time();
			old_mountpoints = g_list_append(old_mountpoints, mp);
		}
	}
	janus_mutex_unlock(&mountpoints_mutex);
	if(watchdog != NULL) {
		g_thread_join(watchdog);
		watchdog = NULL;
	}

	/* FIXME We should destroy the sessions cleanly */
	usleep(500000);
	janus_mutex_lock(&mountpoints_mutex);
	g_hash_table_destroy(mountpoints); /* TODO: @landswellsong do we need to free them? */
	janus_mutex_unlock(&mountpoints_mutex);
	janus_mutex_lock(&sessions_mutex);
	g_hash_table_destroy(sessions);
	janus_mutex_unlock(&sessions_mutex);
	janus_rtpbroadcast_port_manager_destroy();
	g_async_queue_unref(messages);
	messages = NULL;
	sessions = NULL;

	g_atomic_int_set(&initialized, 0);
	g_atomic_int_set(&stopping, 0);
	JANUS_LOG(LOG_INFO, "%s destroyed!\n", JANUS_RTPBROADCAST_NAME);
}

int janus_rtpbroadcast_get_api_compatibility(void) {
	/* Important! This is what your plugin MUST always return: don't lie here or bad things will happen */
	return JANUS_PLUGIN_API_VERSION;
}

int janus_rtpbroadcast_get_version(void) {
	return JANUS_RTPBROADCAST_VERSION;
}

const char *janus_rtpbroadcast_get_version_string(void) {
	return JANUS_RTPBROADCAST_VERSION_STRING;
}

const char *janus_rtpbroadcast_get_description(void) {
	return JANUS_RTPBROADCAST_DESCRIPTION;
}

const char *janus_rtpbroadcast_get_name(void) {
	return JANUS_RTPBROADCAST_NAME;
}

const char *janus_rtpbroadcast_get_author(void) {
	return JANUS_RTPBROADCAST_AUTHOR;
}

const char *janus_rtpbroadcast_get_package(void) {
	return JANUS_RTPBROADCAST_PACKAGE;
}

void janus_rtpbroadcast_create_session(janus_plugin_session *handle, int *error) {
	if(g_atomic_int_get(&stopping) || !g_atomic_int_get(&initialized)) {
		*error = -1;
		return;
	}
	janus_rtpbroadcast_session *session = (janus_rtpbroadcast_session *)g_malloc0(sizeof(janus_rtpbroadcast_session));
	if(session == NULL) {
		JANUS_LOG(LOG_FATAL, "Memory error!\n");
		*error = -2;
		return;
	}
	session->handle = handle;
	session->mountpoint = NULL;	/* This will happen later */
	session->started = FALSE;	/* This will happen later */
	session->paused = FALSE;
	session->destroyed = 0;
	g_atomic_int_set(&session->hangingup, 0);
	handle->plugin_handle = session;
	janus_mutex_lock(&sessions_mutex);
	g_hash_table_insert(sessions, handle, session);
	janus_mutex_unlock(&sessions_mutex);

	return;
}

void janus_rtpbroadcast_destroy_session(janus_plugin_session *handle, int *error) {
	if(g_atomic_int_get(&stopping) || !g_atomic_int_get(&initialized)) {
		*error = -1;
		return;
	}
	janus_rtpbroadcast_session *session = (janus_rtpbroadcast_session *)handle->plugin_handle;
	if(!session) {
		JANUS_LOG(LOG_ERR, "No session associated with this handle...\n");
		*error = -2;
		return;
	}
	JANUS_LOG(LOG_VERB, "Removing streaming session...\n");
	if(session->mountpoint) {
		janus_mutex_lock(&session->mountpoint->mutex);
		session->mountpoint->listeners = g_list_remove_all(session->mountpoint->listeners, session);
		janus_mutex_unlock(&session->mountpoint->mutex);
	}
	janus_mutex_lock(&sessions_mutex);
	if(!session->destroyed) {
		session->destroyed = janus_get_monotonic_time();
		g_hash_table_remove(sessions, handle);
		/* Cleaning up and removing the session is done in a lazy way */
		old_sessions = g_list_append(old_sessions, session);
	}
	janus_mutex_unlock(&sessions_mutex);
	return;
}

char *janus_rtpbroadcast_query_session(janus_plugin_session *handle) {
	if(g_atomic_int_get(&stopping) || !g_atomic_int_get(&initialized)) {
		return NULL;
	}
	janus_rtpbroadcast_session *session = (janus_rtpbroadcast_session *)handle->plugin_handle;
	if(!session) {
		JANUS_LOG(LOG_ERR, "No session associated with this handle...\n");
		return NULL;
	}
	/* What is this user watching, if anything? */
	json_t *info = json_object();
	json_object_set_new(info, "state", json_string(session->mountpoint ? "watching" : "idle"));
	if(session->mountpoint) {
		json_object_set_new(info, "mountpoint_id", json_string(session->mountpoint->id));
		json_object_set_new(info, "mountpoint_name", session->mountpoint->name ? json_string(session->mountpoint->name) : NULL);
	}
	json_object_set_new(info, "destroyed", json_integer(session->destroyed));
	char *info_text = json_dumps(info, JSON_INDENT(3) | JSON_PRESERVE_ORDER);
	json_decref(info);
	return info_text;
}

struct janus_plugin_result *janus_rtpbroadcast_handle_message(janus_plugin_session *handle, char *transaction, char *message, char *sdp_type, char *sdp) {
	if(g_atomic_int_get(&stopping) || !g_atomic_int_get(&initialized))
		return janus_plugin_result_new(JANUS_PLUGIN_ERROR, g_atomic_int_get(&stopping) ? "Shutting down" : "Plugin not initialized");

	/* Pre-parse the message */
	int error_code = 0;
	char error_cause[512];
	json_t *root = NULL;
	json_t *response = NULL;

	/* This might need to be freed at error: label */
	GArray *sources = NULL;

	if(message == NULL) {
		JANUS_LOG(LOG_ERR, "No message??\n");
		error_code = JANUS_RTPBROADCAST_ERROR_NO_MESSAGE;
		g_snprintf(error_cause, 512, "%s", "No message??");
		goto error;
	}
	JANUS_LOG(LOG_VERB, "Handling message: %s\n", message);

	janus_rtpbroadcast_session *session = (janus_rtpbroadcast_session *)handle->plugin_handle;
	if(!session) {
		JANUS_LOG(LOG_ERR, "No session associated with this handle...\n");
		error_code = JANUS_RTPBROADCAST_ERROR_UNKNOWN_ERROR;
		g_snprintf(error_cause, 512, "%s", "session associated with this handle...");
		goto error;
	}
	if(session->destroyed) {
		JANUS_LOG(LOG_ERR, "Session has already been destroyed...\n");
		error_code = JANUS_RTPBROADCAST_ERROR_UNKNOWN_ERROR;
		g_snprintf(error_cause, 512, "%s", "Session has already been destroyed...");
		goto error;
	}
	json_error_t error;
	root = json_loads(message, 0, &error);
	if(!root) {
		JANUS_LOG(LOG_ERR, "JSON error: on line %d: %s\n", error.line, error.text);
		error_code = JANUS_RTPBROADCAST_ERROR_INVALID_JSON;
		g_snprintf(error_cause, 512, "JSON error: on line %d: %s", error.line, error.text);
		goto error;
	}
	if(!json_is_object(root)) {
		JANUS_LOG(LOG_ERR, "JSON error: not an object\n");
		error_code = JANUS_RTPBROADCAST_ERROR_INVALID_JSON;
		g_snprintf(error_cause, 512, "JSON error: not an object");
		goto error;
	}
	/* Get the request first */
	json_t *request = json_object_get(root, "request");
	if(!request) {
		JANUS_LOG(LOG_ERR, "Missing element (request)\n");
		error_code = JANUS_RTPBROADCAST_ERROR_MISSING_ELEMENT;
		g_snprintf(error_cause, 512, "Missing element (request)");
		goto error;
	}
	if(!json_is_string(request)) {
		JANUS_LOG(LOG_ERR, "Invalid element (request should be a string)\n");
		error_code = JANUS_RTPBROADCAST_ERROR_INVALID_ELEMENT;
		g_snprintf(error_cause, 512, "Invalid element (request should be a string)");
		goto error;
	}
	/* Some requests ('create' and 'destroy') can be handled synchronously */
	const char *request_text = json_string_value(request);
	if(!strcasecmp(request_text, "list")) {
		json_t *list = json_array();
		JANUS_LOG(LOG_VERB, "Request for the list of mountpoints\n");
		/* Return a list of all available mountpoints */
		janus_mutex_lock(&mountpoints_mutex);
		GHashTableIter iter;
		gpointer value;
		g_hash_table_iter_init(&iter, mountpoints);
		while (g_hash_table_iter_next(&iter, NULL, &value)) {
			janus_rtpbroadcast_mountpoint *mp = value;
			json_t *ml = json_object();
			json_object_set_new(ml, "id", json_string(mp->id));
			json_object_set_new(ml, "name", json_string(mp->name));
			json_object_set_new(ml, "description", json_string(mp->description));
			/* json_object_set_new(ml, "streamcount", json_integer(mp->sources->len)); */
			json_t *st = json_array();
			guint i;
			for (i = 0; i < mp->sources->len; i++) {
				janus_rtpbroadcast_rtp_source *src = g_array_index(mp->sources, janus_rtpbroadcast_rtp_source*, i);
				json_t *v = json_object();
				json_object_set_new(v, "audioport", json_integer(src->port[AUDIO]));
				json_object_set_new(v, "videoport", json_integer(src->port[VIDEO]));

				json_t *s = json_object();
				janus_mutex_lock(&src->stats.stat_mutex);
				json_object_set_new(s, "min", json_real(src->stats.min));
				json_object_set_new(s, "max", json_real(src->stats.max));
				json_object_set_new(s, "cur", json_real(src->stats.cur));
				json_object_set_new(s, "avg", json_real(src->stats.avg));
				janus_mutex_unlock(&src->stats.stat_mutex);

				json_object_set_new(v, "stats", s);

				json_array_append_new(st, v);
			}
			json_object_set_new(ml, "streams", st);
			/* TODO: @landswellsong do we need to list anything else here? */
			json_array_append_new(list, ml);
		}
		janus_mutex_unlock(&mountpoints_mutex);
		/* Send info back */
		response = json_object();
		json_object_set_new(response, "streaming", json_string("list"));
		json_object_set_new(response, "list", list);
		goto plugin_response;
	} else if(!strcasecmp(request_text, "create")) {
		/* Create a new stream */
		janus_rtpbroadcast_mountpoint *mp = NULL;

	  /* RTP live source (e.g., from gstreamer/ffmpeg/vlc/etc.) */
		json_t *id = json_object_get(root, "id");
		if(!id) {
			JANUS_LOG(LOG_ERR, "Missing element (id)\n");
			error_code = JANUS_RTPBROADCAST_ERROR_MISSING_ELEMENT;
			g_snprintf(error_cause, 512, "Missing element (id)");
			goto error;
		}
		if(!json_is_string(id)) {
			JANUS_LOG(LOG_ERR, "Invalid element (id should be a string)\n");
			error_code = JANUS_RTPBROADCAST_ERROR_INVALID_ELEMENT;
			g_snprintf(error_cause, 512, "Invalid element (id should be a string)");
			goto error;
		}
		json_t *name = json_object_get(root, "name");
		if(name && !json_is_string(name)) {
			JANUS_LOG(LOG_ERR, "Invalid element (name should be a string)\n");
			error_code = JANUS_RTPBROADCAST_ERROR_INVALID_ELEMENT;
			g_snprintf(error_cause, 512, "Invalid element (name should be a string)");
			goto error;
		}
		json_t *desc = json_object_get(root, "description");
		if(desc && !json_is_string(desc)) {
			JANUS_LOG(LOG_ERR, "Invalid element (desc should be a string)\n");
			error_code = JANUS_RTPBROADCAST_ERROR_INVALID_ELEMENT;
			g_snprintf(error_cause, 512, "Invalid element (desc should be a string)");
			goto error;
		}

		/* Streams is an array now, containing pairs of audio+video streams */
		json_t *streams = json_object_get(root, "streams");
		size_t nstreams = json_array_size(streams);
		if (nstreams==0 || !json_is_array(streams)) {
			JANUS_LOG(LOG_ERR, "Invalid element (streams should be a non-empty array)\n");
			error_code = JANUS_RTPBROADCAST_ERROR_INVALID_ELEMENT;
			g_snprintf(error_cause, 512, "Invalid element (streams should be a non-empty array)");
			goto error;
		}

		sources = g_array_sized_new(FALSE, FALSE,
			sizeof(janus_rtpbroadcast_rtp_source_request), nstreams);
		size_t i;
		json_t *v;

		/* Jansson's nomenclature changed a bit between versions */
#ifdef json_array_foreach
		json_array_foreach(streams, i, v) {
#else
		for (i = 0; i < json_array_size(streams); i++) {
			v = json_array_get(streams, i);
#endif
			if (v && !json_is_object(v)) {
				JANUS_LOG(LOG_ERR, "Invalid element (streams elements should be objects)\n");
				error_code = JANUS_RTPBROADCAST_ERROR_INVALID_ELEMENT;
				g_snprintf(error_cause, 512, "Invalid value (streams elements should be objects)");
				goto error;
			}

			janus_rtpbroadcast_rtp_source_request req = {
				NULL, NULL,
				0, 0,
				NULL, NULL,
				NULL, NULL,
			}; /* FIXME @landswellsong check if it's correct initialization */

			/* Audio/Video stream params */
			size_t j;
			for (j = AUDIO; j <= VIDEO; j++) {
				char tmpnm[512];

				g_snprintf(tmpnm, 512, "%smcast", av_names[j]);
				json_t *mcast = json_object_get(v, tmpnm);
				if(mcast && !json_is_string(mcast)) {
					JANUS_LOG(LOG_ERR, "Invalid element (%s should be a string)\n", tmpnm);
					error_code = JANUS_RTPBROADCAST_ERROR_INVALID_ELEMENT;
					g_snprintf(error_cause, 512, "Invalid element (%s should be a string)", tmpnm);
					goto error;
				} else {
					req.mcast[j] = (char *)json_string_value(mcast);
				}

				g_snprintf(tmpnm, 512, "%spt", av_names[j]);
				json_t *pt = json_object_get(v, tmpnm);
				if(!pt) {
					JANUS_LOG(LOG_ERR, "Missing element (%s)\n", tmpnm);
					error_code = JANUS_RTPBROADCAST_ERROR_MISSING_ELEMENT;
					g_snprintf(error_cause, 512, "Missing element (%s)", tmpnm);
					goto error;
				}
				if(!json_is_integer(pt) || json_integer_value(pt) < 0) {
					JANUS_LOG(LOG_ERR, "Invalid element (%s should be a positive integer)\n", tmpnm);
					error_code = JANUS_RTPBROADCAST_ERROR_INVALID_ELEMENT;
					g_snprintf(error_cause, 512, "Invalid element (%s should be a positive integer)", tmpnm);
					goto error;
				}
				req.codec[j] = json_integer_value(pt);

				g_snprintf(tmpnm, 512, "%srtpmap", av_names[j]);
				json_t *rtpmap = json_object_get(v, tmpnm);
				if(!rtpmap) {
					JANUS_LOG(LOG_ERR, "Missing element (%s)\n", tmpnm);
					error_code = JANUS_RTPBROADCAST_ERROR_MISSING_ELEMENT;
					g_snprintf(error_cause, 512, "Missing element (%s)", tmpnm);
					goto error;
				}
				if(!json_is_string(rtpmap)) {
					JANUS_LOG(LOG_ERR, "Invalid element (%s should be a string)\n", tmpnm);
					error_code = JANUS_RTPBROADCAST_ERROR_INVALID_ELEMENT;
					g_snprintf(error_cause, 512, "Invalid element (%s should be a string)", tmpnm);
					goto error;
				}
				req.rtpmap[j] = (char *)json_string_value(rtpmap);

				g_snprintf(tmpnm, 512, "%sfmtp", av_names[j]);
				json_t *fmtp = json_object_get(v, tmpnm);
				if(fmtp && !json_is_string(fmtp)) {
					JANUS_LOG(LOG_ERR, "Invalid element (%s should be a string)\n", tmpnm);
					error_code = JANUS_RTPBROADCAST_ERROR_INVALID_ELEMENT;
					g_snprintf(error_cause, 512, "Invalid element (%s should be a string)", tmpnm);
					goto error;
				}
				req.fmtp[j] = (char *)json_string_value(fmtp);
			}
			/* All done, append to array */
			g_array_append_val(sources, req);
		}
		if(id == NULL) {
			JANUS_LOG(LOG_VERB, "Missing id, will generate a random one...\n");
		} else {
			janus_mutex_lock(&mountpoints_mutex);
			mp = g_hash_table_lookup(mountpoints, json_string_value(id));
			janus_mutex_unlock(&mountpoints_mutex);
			if(mp != NULL) {
				JANUS_LOG(LOG_ERR, "A stream with the provided ID already exists\n");
				error_code = JANUS_RTPBROADCAST_ERROR_CANT_CREATE;
				g_snprintf(error_cause, 512, "A stream with the provided ID already exists");
				goto error;
			}
		}
		mp = janus_rtpbroadcast_create_rtp_source(
				id ? (char *)json_string_value(id) : NULL,
				name ? (char *)json_string_value(name) : NULL,
				desc ? (char *)json_string_value(desc) : NULL,
				sources);
		if(mp == NULL) {
			JANUS_LOG(LOG_ERR, "Error creating 'rtp' stream...\n");
			error_code = JANUS_RTPBROADCAST_ERROR_CANT_CREATE;
			g_snprintf(error_cause, 512, "Error creating 'rtp' stream");
			goto error;
		}
		/* Send info back */
		response = json_object();
		json_object_set_new(response, "streaming", json_string("created"));
		json_object_set_new(response, "created", json_string(mp->name));
		json_t *ml = json_object();
		json_object_set_new(ml, "id", json_string(mp->id));
		json_object_set_new(ml, "description", json_string(mp->description));
/*		json_object_set_new(ml, "streamcount", json_integer(nstreams)); */
		json_t *st = json_array();
		for (i = 0; i < mp->sources->len; i++) {
			json_t *v = json_object();
			json_object_set_new(v, "audioport", json_integer(g_array_index(mp->sources, janus_rtpbroadcast_rtp_source*, i)->port[AUDIO]));
			json_object_set_new(v, "videoport", json_integer(g_array_index(mp->sources, janus_rtpbroadcast_rtp_source*, i)->port[VIDEO]));
			json_array_append_new(st, v);
		}
		json_object_set_new(ml, "streams", st);
		json_object_set_new(response, "stream", ml);
		goto plugin_response;
	} else if(!strcasecmp(request_text, "destroy")) {
		/* Get rid of an existing stream (notice this doesn't remove it from the config file, though) */
		json_t *id = json_object_get(root, "id");
		if(!id) {
			JANUS_LOG(LOG_ERR, "Missing element (id)\n");
			error_code = JANUS_RTPBROADCAST_ERROR_MISSING_ELEMENT;
			g_snprintf(error_cause, 512, "Missing element (id)");
			goto error;
		}
		if(!json_is_string(id) < 0) {
			JANUS_LOG(LOG_ERR, "Invalid element (id should be a string)\n");
			error_code = JANUS_RTPBROADCAST_ERROR_INVALID_ELEMENT;
			g_snprintf(error_cause, 512, "Invalid element (id should be a string)");
			goto error;
		}
		const char *id_value = json_string_value(id);
		janus_mutex_lock(&mountpoints_mutex);
		janus_rtpbroadcast_mountpoint *mp = g_hash_table_lookup(mountpoints, id_value);
		if(mp == NULL) {
			janus_mutex_unlock(&mountpoints_mutex);
			JANUS_LOG(LOG_VERB, "No such mountpoint/stream %s\n", id_value);
			error_code = JANUS_RTPBROADCAST_ERROR_NO_SUCH_MOUNTPOINT;
			g_snprintf(error_cause, 512, "No such mountpoint/stream %s", id_value);
			goto error;
		}
		JANUS_LOG(LOG_VERB, "Request to unmount mountpoint/stream %s\n", id_value);
		/* FIXME Should we kick the current viewers as well? */
		janus_mutex_lock(&mp->mutex);
		GList *viewer = g_list_first(mp->listeners);
		/* Prepare JSON event */
		json_t *event = json_object();
		json_object_set_new(event, "streaming", json_string("event"));
		json_t *result = json_object();
		json_object_set_new(result, "status", json_string("stopped"));
		json_object_set_new(event, "result", result);
		char *event_text = json_dumps(event, JSON_INDENT(3) | JSON_PRESERVE_ORDER);
		json_decref(event);
		while(viewer) {
			janus_rtpbroadcast_session *session = (janus_rtpbroadcast_session *)viewer->data;
			if(session != NULL) {
				session->stopping = TRUE;
				session->started = FALSE;
				session->paused = FALSE;
				session->mountpoint = NULL;
				/* Tell the core to tear down the PeerConnection, hangup_media will do the rest */
				gateway->push_event(session->handle, &janus_rtpbroadcast_plugin, NULL, event_text, NULL, NULL);
				gateway->close_pc(session->handle);
			}
			mp->listeners = g_list_remove_all(mp->listeners, session);
			viewer = g_list_first(mp->listeners);
		}
		g_free(event_text);
		janus_mutex_unlock(&mp->mutex);
		/* Remove mountpoint from the hashtable: this will get it destroyed */
		if(!mp->destroyed) {
			mp->destroyed = janus_get_monotonic_time();
			g_hash_table_remove(mountpoints, id_value);
			/* Cleaning up and removing the mountpoint is done in a lazy way */
			old_mountpoints = g_list_append(old_mountpoints, mp);
		}
		janus_mutex_unlock(&mountpoints_mutex);
		/* Send info back */
		response = json_object();
		json_object_set_new(response, "streaming", json_string("destroyed"));
		json_object_set_new(response, "destroyed", json_string(id_value));
		goto plugin_response;
	} else if(!strcasecmp(request_text, "recording")) {
		#if 0
		/* We can start/stop recording a live, RTP-based stream */
		json_t *action = json_object_get(root, "action");
		if(!action) {
			JANUS_LOG(LOG_ERR, "Missing element (action)\n");
			error_code = JANUS_RTPBROADCAST_ERROR_MISSING_ELEMENT;
			g_snprintf(error_cause, 512, "Missing element (action)");
			goto error;
		}
		if(!json_is_string(action)) {
			JANUS_LOG(LOG_ERR, "Invalid element (action should be a string)\n");
			error_code = JANUS_RTPBROADCAST_ERROR_INVALID_ELEMENT;
			g_snprintf(error_cause, 512, "Invalid element (action should be a string)");
			goto error;
		}
		const char *action_text = json_string_value(action);
		if(strcasecmp(action_text, "start") && strcasecmp(action_text, "stop")) {
			JANUS_LOG(LOG_ERR, "Invalid action (should be start|stop)\n");
			error_code = JANUS_RTPBROADCAST_ERROR_INVALID_ELEMENT;
			g_snprintf(error_cause, 512, "Invalid action (should be start|stop)");
			goto error;
		}
		json_t *id = json_object_get(root, "id");
		if(!id) {
			JANUS_LOG(LOG_ERR, "Missing element (id)\n");
			error_code = JANUS_RTPBROADCAST_ERROR_MISSING_ELEMENT;
			g_snprintf(error_cause, 512, "Missing element (id)");
			goto error;
		}
		if(!json_is_string(id)) {
			JANUS_LOG(LOG_ERR, "Invalid element (id should be a string)\n");
			error_code = JANUS_RTPBROADCAST_ERROR_INVALID_ELEMENT;
			g_snprintf(error_cause, 512, "Invalid element (id should be a string)");
			goto error;
		}
		char *id_value = json_string_value(id);
		janus_mutex_lock(&mountpoints_mutex);
		janus_rtpbroadcast_mountpoint *mp = g_hash_table_lookup(mountpoints, id_value);
		if(mp == NULL) {
			janus_mutex_unlock(&mountpoints_mutex);
			JANUS_LOG(LOG_VERB, "No such mountpoint/stream %s\n", id_value);
			error_code = JANUS_RTPBROADCAST_ERROR_NO_SUCH_MOUNTPOINT;
			g_snprintf(error_cause, 512, "No such mountpoint/stream %s", id_value);
			goto error;
		}
		if(!strcasecmp(action_text, "start")) {
			/* Start a recording for audio and/or video */
			json_t *audio = json_object_get(root, "audio");
			if(audio && !json_is_string(audio)) {
				janus_mutex_unlock(&mountpoints_mutex);
				JANUS_LOG(LOG_ERR, "Invalid element (audio should be a string)\n");
				error_code = JANUS_RTPBROADCAST_ERROR_INVALID_ELEMENT;
				g_snprintf(error_cause, 512, "Invalid value (audio should be a string)");
				goto error;
			}
			json_t *video = json_object_get(root, "video");
			if(video && !json_is_string(video)) {
				janus_mutex_unlock(&mountpoints_mutex);
				JANUS_LOG(LOG_ERR, "Invalid element (video should be a string)\n");
				error_code = JANUS_RTPBROADCAST_ERROR_INVALID_ELEMENT;
				g_snprintf(error_cause, 512, "Invalid value (video should be a string)");
				goto error;
			}
			if((audio && mp->source->arc) || (video && mp->source->vrc)) {
				janus_mutex_unlock(&mountpoints_mutex);
				JANUS_LOG(LOG_ERR, "Recording for audio and/or video already started for this stream\n");
				error_code = JANUS_RTPBROADCAST_ERROR_INVALID_REQUEST;
				g_snprintf(error_cause, 512, "Recording for audio and/or video already started for this stream");
				goto error;
			}
			if(!audio && !video) {
				janus_mutex_unlock(&mountpoints_mutex);
				JANUS_LOG(LOG_ERR, "Missing audio and/or video\n");
				error_code = JANUS_RTPBROADCAST_ERROR_INVALID_REQUEST;
				g_snprintf(error_cause, 512, "Missing audio and/or video");
				goto error;
			}
			if(audio) {
				const char *audiofile = json_string_value(audio);
				mp->source->arc = janus_recorder_create(NULL, 0, (char *)audiofile);
				if(mp->source->arc == NULL) {
					JANUS_LOG(LOG_ERR, "Error starting recorder for audio\n");
				} else {
					JANUS_LOG(LOG_INFO, "[%s] Audio recording started\n", mp->name);
				}
			}
			if(video) {
				const char *videofile = json_string_value(video);
				mp->source->vrc = janus_recorder_create(NULL, 1, (char *)videofile);
				if(mp->source->vrc == NULL) {
					JANUS_LOG(LOG_ERR, "Error starting recorder for video\n");
				} else {
					JANUS_LOG(LOG_INFO, "[%s] Video recording started\n", mp->name);
				}
			}
			janus_mutex_unlock(&mountpoints_mutex);
			/* Send a success response back */
			response = json_object();
			json_object_set_new(response, "streaming", json_string("ok"));
			goto plugin_response;
		} else if(!strcasecmp(action_text, "stop")) {
			/* Stop the recording */
			json_t *audio = json_object_get(root, "audio");
			if(audio && !json_is_boolean(audio)) {
				janus_mutex_unlock(&mountpoints_mutex);
				JANUS_LOG(LOG_ERR, "Invalid element (audio should be a boolean)\n");
				error_code = JANUS_RTPBROADCAST_ERROR_INVALID_ELEMENT;
				g_snprintf(error_cause, 512, "Invalid value (audio should be a boolean)");
				goto error;
			}
			json_t *video = json_object_get(root, "video");
			if(video && !json_is_boolean(video)) {
				janus_mutex_unlock(&mountpoints_mutex);
				JANUS_LOG(LOG_ERR, "Invalid element (video should be a boolean)\n");
				error_code = JANUS_RTPBROADCAST_ERROR_INVALID_ELEMENT;
				g_snprintf(error_cause, 512, "Invalid value (video should be a boolean)");
				goto error;
			}
			if(!audio && !video) {
				janus_mutex_unlock(&mountpoints_mutex);
				JANUS_LOG(LOG_ERR, "Missing audio and/or video\n");
				error_code = JANUS_RTPBROADCAST_ERROR_INVALID_REQUEST;
				g_snprintf(error_cause, 512, "Missing audio and/or video");
				goto error;
			}
			if(audio && json_is_true(audio) && mp->source->arc) {
				/* Close the audio recording */
				janus_recorder_close(mp->source->arc);
				JANUS_LOG(LOG_INFO, "[%s] Closed audio recording %s\n", mp->name, mp->source->arc->filename ? mp->source->arc->filename : "??");
				janus_recorder *tmp = mp->source->arc;
				mp->source->arc = NULL;
				janus_recorder_free(tmp);
			}
			if(video && json_is_true(video) && mp->source->vrc) {
				/* Close the video recording */
				janus_recorder_close(mp->source->vrc);
				JANUS_LOG(LOG_INFO, "[%s] Closed video recording %s\n", mp->name, mp->source->vrc->filename ? mp->source->vrc->filename : "??");
				janus_recorder *tmp = mp->source->vrc;
				mp->source->vrc = NULL;
				janus_recorder_free(tmp);
			}
			janus_mutex_unlock(&mountpoints_mutex);
			/* Send a success response back */
			response = json_object();
			json_object_set_new(response, "streaming", json_string("ok"));
			goto plugin_response;
		}
		#endif // record
	} else if(!strcasecmp(request_text, "enable") || !strcasecmp(request_text, "disable")) {
		/* A request to enable/disable a mountpoint */
		json_t *id = json_object_get(root, "id");
		if(!id) {
			JANUS_LOG(LOG_ERR, "Missing element (id)\n");
			error_code = JANUS_RTPBROADCAST_ERROR_MISSING_ELEMENT;
			g_snprintf(error_cause, 512, "Missing element (id)");
			goto error;
		}
		if(!json_is_string(id)) {
			JANUS_LOG(LOG_ERR, "Invalid element (id should be a string)\n");
			error_code = JANUS_RTPBROADCAST_ERROR_INVALID_ELEMENT;
			g_snprintf(error_cause, 512, "Invalid element (id should be a string)");
			goto error;
		}
		const char *id_value = json_string_value(id);
		janus_mutex_lock(&mountpoints_mutex);
		janus_rtpbroadcast_mountpoint *mp = g_hash_table_lookup(mountpoints, id_value);
		if(mp == NULL) {
			janus_mutex_unlock(&mountpoints_mutex);
			JANUS_LOG(LOG_VERB, "No such mountpoint/stream %s\n", id_value);
			error_code = JANUS_RTPBROADCAST_ERROR_NO_SUCH_MOUNTPOINT;
			g_snprintf(error_cause, 512, "No such mountpoint/stream %s", id_value);
			goto error;
		}
		if(!strcasecmp(request_text, "enable")) {
			/* Enable a previously disabled mountpoint */
			JANUS_LOG(LOG_INFO, "[%s] Stream enabled\n", mp->name);
			mp->enabled = TRUE;
			/* FIXME: Should we notify the listeners, or is this up to the controller application? */
		} else {
			/* Disable a previously enabled mountpoint */
			JANUS_LOG(LOG_INFO, "[%s] Stream disabled\n", mp->name);
			mp->enabled = FALSE;
			/* Any recording to close? */
			size_t j;
			for (j = AUDIO; j <= VIDEO; j++) {
				if(mp->rc[j]) {
					janus_recorder_close(mp->rc[j]);
					JANUS_LOG(LOG_INFO, "[%s] Closed %s recording %s\n", mp->name, av_names[j], mp->rc[j]->filename ? mp->rc[j]->filename : "??");
					janus_recorder *tmp = mp->rc[j];
					mp->rc[j] = NULL;
					janus_recorder_free(tmp);
				}
			}
			/* FIXME: Should we notify the listeners, or is this up to the controller application? */
		}
		janus_mutex_unlock(&mountpoints_mutex);
		/* Send a success response back */
		response = json_object();
		json_object_set_new(response, "streaming", json_string("ok"));
		goto plugin_response;
	} else if(!strcasecmp(request_text, "watch") || !strcasecmp(request_text, "start")
			|| !strcasecmp(request_text, "pause") || !strcasecmp(request_text, "stop")
			|| !strcasecmp(request_text, "switch")) {
		/* These messages are handled asynchronously */
		janus_rtpbroadcast_message *msg = g_malloc0(sizeof(janus_rtpbroadcast_message));
		if(msg == NULL) {
			JANUS_LOG(LOG_FATAL, "Memory error!\n");
			error_code = JANUS_RTPBROADCAST_ERROR_UNKNOWN_ERROR;
			g_snprintf(error_cause, 512, "Memory error");
			goto error;
		}

		g_free(message);
		msg->handle = handle;
		msg->transaction = transaction;
		msg->message = root;
		msg->sdp_type = sdp_type;
		msg->sdp = sdp;

		g_async_queue_push(messages, msg);

		return janus_plugin_result_new(JANUS_PLUGIN_OK_WAIT, NULL);
	} else {
		JANUS_LOG(LOG_VERB, "Unknown request '%s'\n", request_text);
		error_code = JANUS_RTPBROADCAST_ERROR_INVALID_REQUEST;
		g_snprintf(error_cause, 512, "Unknown request '%s'", request_text);
		goto error;
	}

plugin_response:
		{
			if(!response) {
				error_code = JANUS_RTPBROADCAST_ERROR_UNKNOWN_ERROR;
				g_snprintf(error_cause, 512, "Invalid response");
				goto error;
			}
			if(root != NULL)
				json_decref(root);
			g_free(transaction);
			g_free(message);
			g_free(sdp_type);
			g_free(sdp);

			if (sources != NULL)
				g_array_free(sources, TRUE);

			char *response_text = json_dumps(response, JSON_INDENT(3) | JSON_PRESERVE_ORDER);
			json_decref(response);
			janus_plugin_result *result = janus_plugin_result_new(JANUS_PLUGIN_OK, response_text);
			g_free(response_text);
			return result;
		}

error:
		{
			if(root != NULL)
				json_decref(root);
			g_free(transaction);
			g_free(message);
			g_free(sdp_type);
			g_free(sdp);

			if (sources != NULL)
				g_array_free(sources, TRUE);

			/* Prepare JSON error event */
			json_t *event = json_object();
			json_object_set_new(event, "streaming", json_string("event"));
			json_object_set_new(event, "error_code", json_integer(error_code));
			json_object_set_new(event, "error", json_string(error_cause));
			char *event_text = json_dumps(event, JSON_INDENT(3) | JSON_PRESERVE_ORDER);
			json_decref(event);
			janus_plugin_result *result = janus_plugin_result_new(JANUS_PLUGIN_OK, event_text);
			g_free(event_text);
			return result;
		}

}

void janus_rtpbroadcast_setup_media(janus_plugin_session *handle) {
	JANUS_LOG(LOG_INFO, "WebRTC media is now available\n");
	if(g_atomic_int_get(&stopping) || !g_atomic_int_get(&initialized))
		return;
	janus_rtpbroadcast_session *session = (janus_rtpbroadcast_session *)handle->plugin_handle;
	if(!session) {
		JANUS_LOG(LOG_ERR, "No session associated with this handle...\n");
		return;
	}
	if(session->destroyed)
		return;
	g_atomic_int_set(&session->hangingup, 0);
	/* TODO Only start streaming when we get this event */
	memset(&session->context, 0, sizeof(session->context));
	session->started = TRUE;
	/* Prepare JSON event */
	json_t *event = json_object();
	json_object_set_new(event, "streaming", json_string("event"));
	json_t *result = json_object();
	json_object_set_new(result, "status", json_string("started"));
	json_object_set_new(event, "result", result);
	char *event_text = json_dumps(event, JSON_INDENT(3) | JSON_PRESERVE_ORDER);
	json_decref(event);
	JANUS_LOG(LOG_VERB, "Pushing event: %s\n", event_text);
	int ret = gateway->push_event(handle, &janus_rtpbroadcast_plugin, NULL, event_text, NULL, NULL);
	JANUS_LOG(LOG_VERB, "  >> %d (%s)\n", ret, janus_get_api_error(ret));
	g_free(event_text);
}

void janus_rtpbroadcast_incoming_rtp(janus_plugin_session *handle, int video, char *buf, int len) {
	if(handle == NULL || handle->stopped || g_atomic_int_get(&stopping) || !g_atomic_int_get(&initialized))
		return;
	/* FIXME We don't care about what the browser sends us, we're sendonly */
}

void janus_rtpbroadcast_incoming_rtcp(janus_plugin_session *handle, int video, char *buf, int len) {
	if(handle == NULL || handle->stopped || g_atomic_int_get(&stopping) || !g_atomic_int_get(&initialized))
		return;
	/* We might interested in the available bandwidth that the user advertizes */
	uint64_t bw = janus_rtcp_get_remb(buf, len);
	if(bw > 0) {
		JANUS_LOG(LOG_HUGE, "REMB for this PeerConnection: %"SCNu64"\n", bw);
		/* TODO Use this somehow (e.g., notification towards application?) */
	}
	/* FIXME Maybe we should care about RTCP, but not now */
}

void janus_rtpbroadcast_hangup_media(janus_plugin_session *handle) {
	JANUS_LOG(LOG_INFO, "No WebRTC media anymore\n");
	if(g_atomic_int_get(&stopping) || !g_atomic_int_get(&initialized))
		return;
	janus_rtpbroadcast_session *session = (janus_rtpbroadcast_session *)handle->plugin_handle;
	if(!session) {
		JANUS_LOG(LOG_ERR, "No session associated with this handle...\n");
		return;
	}
	if(session->destroyed)
		return;
	if(g_atomic_int_add(&session->hangingup, 1))
		return;
	/* FIXME Simulate a "stop" coming from the browser */
	janus_rtpbroadcast_message *msg = g_malloc0(sizeof(janus_rtpbroadcast_message));
	msg->handle = handle;
	msg->message = json_loads("{\"request\":\"stop\"}", 0, NULL);
	msg->transaction = NULL;
	msg->sdp_type = NULL;
	msg->sdp = NULL;
	g_async_queue_push(messages, msg);
}

/* Thread to handle incoming messages */
static void *janus_rtpbroadcast_handler(void *data) {
	JANUS_LOG(LOG_VERB, "Joining Streaming handler thread\n");
	janus_rtpbroadcast_message *msg = NULL;
	int error_code = 0;
	char *error_cause = g_malloc0(1024);
	if(error_cause == NULL) {
		JANUS_LOG(LOG_FATAL, "Memory error!\n");
		return NULL;
	}
	json_t *root = NULL;
	while(g_atomic_int_get(&initialized) && !g_atomic_int_get(&stopping)) {
		if(!messages || (msg = g_async_queue_try_pop(messages)) == NULL) {
			usleep(50000);
			continue;
		}
		janus_rtpbroadcast_session *session = (janus_rtpbroadcast_session *)msg->handle->plugin_handle;
		if(!session) {
			JANUS_LOG(LOG_ERR, "No session associated with this handle...\n");
			janus_rtpbroadcast_message_free(msg);
			continue;
		}
		if(session->destroyed) {
			janus_rtpbroadcast_message_free(msg);
			continue;
		}
		/* Handle request */
		error_code = 0;
		root = NULL;
		if(msg->message == NULL) {
			JANUS_LOG(LOG_ERR, "No message??\n");
			error_code = JANUS_RTPBROADCAST_ERROR_NO_MESSAGE;
			g_snprintf(error_cause, 512, "%s", "No message??");
			goto error;
		}
		root = msg->message;
		/* Get the request first */
		json_t *request = json_object_get(root, "request");
		if(!request) {
			JANUS_LOG(LOG_ERR, "Missing element (request)\n");
			error_code = JANUS_RTPBROADCAST_ERROR_MISSING_ELEMENT;
			g_snprintf(error_cause, 512, "Missing element (request)");
			goto error;
		}
		if(!json_is_string(request)) {
			JANUS_LOG(LOG_ERR, "Invalid element (request should be a string)\n");
			error_code = JANUS_RTPBROADCAST_ERROR_INVALID_ELEMENT;
			g_snprintf(error_cause, 512, "Invalid element (request should be a string)");
			goto error;
		}
		const char *request_text = json_string_value(request);
		json_t *result = NULL;
		const char *sdp_type = NULL;
		char *sdp = NULL;
		/* All these requests can only be handled asynchronously */
		if(!strcasecmp(request_text, "watch")) {
			json_t *id = json_object_get(root, "id");
			if(!id) {
				JANUS_LOG(LOG_ERR, "Missing element (id)\n");
				error_code = JANUS_RTPBROADCAST_ERROR_MISSING_ELEMENT;
				g_snprintf(error_cause, 512, "Missing element (id)");
				goto error;
			}
			if(!json_is_string(id)) {
				JANUS_LOG(LOG_ERR, "Invalid element (id should be a string)\n");
				error_code = JANUS_RTPBROADCAST_ERROR_INVALID_ELEMENT;
				g_snprintf(error_cause, 512, "Invalid element (id should be a string)");
				goto error;
			}
			const char *id_value = json_string_value(id);
			janus_mutex_lock(&mountpoints_mutex);
			janus_rtpbroadcast_mountpoint *mp = g_hash_table_lookup(mountpoints, id_value);
			if(mp == NULL) {
				janus_mutex_unlock(&mountpoints_mutex);
				JANUS_LOG(LOG_VERB, "No such mountpoint/stream %s\n", id_value);
				error_code = JANUS_RTPBROADCAST_ERROR_NO_SUCH_MOUNTPOINT;
				g_snprintf(error_cause, 512, "No such mountpoint/stream %s", id_value);
				goto error;
			}
			janus_mutex_unlock(&mountpoints_mutex);
			JANUS_LOG(LOG_VERB, "Request to watch mountpoint/stream %s\n", id_value);
			session->stopping = FALSE;
			session->mountpoint = mp;
			/* TODO Check if user is already watching a stream, if the video is active, etc. */
			janus_mutex_lock(&mp->mutex);
			mp->listeners = g_list_append(mp->listeners, session);
			janus_mutex_unlock(&mp->mutex);
			sdp_type = "offer";	/* We're always going to do the offer ourselves, never answer */
			char sdptemp[2048];
			memset(sdptemp, 0, 2048);
			gchar buffer[512];
			memset(buffer, 0, 512);
			gint64 sessid = janus_get_real_time();
			gint64 version = sessid;	/* FIXME This needs to be increased when it changes, so time should be ok */
			g_snprintf(buffer, 512,
				"v=0\r\no=%s %"SCNu64" %"SCNu64" IN IP4 127.0.0.1\r\n",
					"-", sessid, version);
			g_strlcat(sdptemp, buffer, 2048);
			g_strlcat(sdptemp, "s=Streaming Test\r\nt=0 0\r\n", 2048); /* FIXME @landswellsong: maybe some sane name here? */
			/* FIXME @landswellsong: temporary code for single stream only */
			/* ASSUMING #sources > 0 */
			janus_rtpbroadcast_codecs codecs = g_array_index(mp->sources, janus_rtpbroadcast_rtp_source*, 0)->codecs;

			size_t j;
			for (j = AUDIO; j <= VIDEO; j++) {
				if(codecs.pt[j] >= 0) {
					/* Add audio/video line */
					g_snprintf(buffer, 512,
						"m=%s 1 RTP/SAVPF %d\r\n"
						"c=IN IP4 1.1.1.1\r\n",
						av_names[j],
						codecs.pt[j]);
					g_strlcat(sdptemp, buffer, 2048);
					if(codecs.rtpmap[j]) {
						g_snprintf(buffer, 512,
							"a=rtpmap:%d %s\r\n",
							codecs.pt[j], codecs.rtpmap[j]);
						g_strlcat(sdptemp, buffer, 2048);
					}
					if(codecs.fmtp[j]) {
						g_snprintf(buffer, 512,
							"a=fmtp:%d %s\r\n",
							codecs.pt[j], codecs.fmtp[j]);
						g_strlcat(sdptemp, buffer, 2048);
					}
					if (j == VIDEO) {
						g_snprintf(buffer, 512,
							"a=rtcp-fb:%d nack\r\n",
							codecs.pt[j]);
						g_strlcat(sdptemp, buffer, 2048);
						g_snprintf(buffer, 512,
							"a=rtcp-fb:%d goog-remb\r\n",
							codecs.pt[j]);
						g_strlcat(sdptemp, buffer, 2048);
					}
					g_strlcat(sdptemp, "a=sendonly\r\n", 2048);
				}
			}

			sdp = g_strdup(sdptemp);
			JANUS_LOG(LOG_VERB, "Going to offer this SDP:\n%s\n", sdp);
			result = json_object();
			json_object_set_new(result, "status", json_string("preparing"));
		} else if(!strcasecmp(request_text, "start")) {
			#if 0
			if(session->mountpoint == NULL) {
				JANUS_LOG(LOG_VERB, "Can't start: no mountpoint set\n");
				error_code = JANUS_RTPBROADCAST_ERROR_NO_SUCH_MOUNTPOINT;
				g_snprintf(error_cause, 512, "Can't start: no mountpoint set");
				goto error;
			}
			JANUS_LOG(LOG_VERB, "Starting the streaming\n");
			session->paused = FALSE;
			result = json_object();
			/* We wait for the setup_media event to start: on the other hand, it may have already arrived */
			json_object_set_new(result, "status", json_string(session->started ? "started" : "starting"));
		} else if(!strcasecmp(request_text, "pause")) {
			if(session->mountpoint == NULL) {
				JANUS_LOG(LOG_VERB, "Can't pause: no mountpoint set\n");
				error_code = JANUS_RTPBROADCAST_ERROR_NO_SUCH_MOUNTPOINT;
				g_snprintf(error_cause, 512, "Can't start: no mountpoint set");
				goto error;
			}
			JANUS_LOG(LOG_VERB, "Pausing the streaming\n");
			session->paused = TRUE;
			result = json_object();
			json_object_set_new(result, "status", json_string("pausing"));
		} else if(!strcasecmp(request_text, "switch")) {
			/* This listener wants to switch to a different mountpoint
			 * NOTE: this only works for live RTP streams as of now: you
			 * cannot, for instance, switch from a live RTP mountpoint to
			 * an on demand one or viceversa (TBD.) */
			janus_rtpbroadcast_mountpoint *oldmp = session->mountpoint;
			if(oldmp == NULL) {
				JANUS_LOG(LOG_VERB, "Can't switch: not on a mountpoint\n");
				error_code = JANUS_RTPBROADCAST_ERROR_NO_SUCH_MOUNTPOINT;
				g_snprintf(error_cause, 512, "Can't switch: not on a mountpoint");
				goto error;
			}
			json_t *id = json_object_get(root, "id");
			if(!id) {
				JANUS_LOG(LOG_ERR, "Missing element (id)\n");
				error_code = JANUS_RTPBROADCAST_ERROR_MISSING_ELEMENT;
				g_snprintf(error_cause, 512, "Missing element (id)");
				goto error;
			}
			if(!json_is_string(id)) {
				JANUS_LOG(LOG_ERR, "Invalid element (id should be a string)\n");
				error_code = JANUS_RTPBROADCAST_ERROR_INVALID_ELEMENT;
				g_snprintf(error_cause, 512, "Invalid element (id should be a string)");
				goto error;
			}
			char *id_value = json_string_value(id);
			janus_mutex_lock(&mountpoints_mutex);
			janus_rtpbroadcast_mountpoint *mp = g_hash_table_lookup(mountpoints, id_value);
			if(mp == NULL) {
				janus_mutex_unlock(&mountpoints_mutex);
				JANUS_LOG(LOG_VERB, "No such mountpoint/stream %s\n", id_value);
				error_code = JANUS_RTPBROADCAST_ERROR_NO_SUCH_MOUNTPOINT;
				g_snprintf(error_cause, 512, "No such mountpoint/stream %s", id_value);
				goto error;
			}
			janus_mutex_unlock(&mountpoints_mutex);
			JANUS_LOG(LOG_VERB, "Request to switch to mountpoint/stream %s (old: %s)\n", id_value, oldmp->id);
			session->paused = TRUE;
			/* Unsubscribe from the previous mountpoint and subscribe to the new one */
			janus_mutex_lock(&oldmp->mutex);
			oldmp->listeners = g_list_remove_all(oldmp->listeners, session);
			janus_mutex_unlock(&oldmp->mutex);
			/* Subscribe to the new one */
			janus_mutex_lock(&mp->mutex);
			mp->listeners = g_list_append(mp->listeners, session);
			janus_mutex_unlock(&mp->mutex);
			session->mountpoint = mp;
			session->paused = FALSE;
			/* Done */
			result = json_object();
			json_object_set_new(result, "streaming", json_string("event"));
			json_object_set_new(result, "switched", json_string("ok"));
			json_object_set_new(result, "id", json_string(id_value));
			#endif // start
		} else if(!strcasecmp(request_text, "stop")) {
			#if 0
			if(session->stopping || !session->started) {
				/* Been there, done that: ignore */
				janus_rtpbroadcast_message_free(msg);
				continue;
			}
			JANUS_LOG(LOG_VERB, "Stopping the streaming\n");
			session->stopping = TRUE;
			session->started = FALSE;
			session->paused = FALSE;
			result = json_object();
			json_object_set_new(result, "status", json_string("stopping"));
			if(session->mountpoint) {
				janus_mutex_lock(&session->mountpoint->mutex);
				JANUS_LOG(LOG_VERB, "  -- Removing the session from the mountpoint listeners\n");
				if(g_list_find(session->mountpoint->listeners, session) != NULL) {
					JANUS_LOG(LOG_VERB, "  -- -- Found!\n");
				}
				session->mountpoint->listeners = g_list_remove_all(session->mountpoint->listeners, session);
				janus_mutex_unlock(&session->mountpoint->mutex);
			}
			session->mountpoint = NULL;
			/* Tell the core to tear down the PeerConnection, hangup_media will do the rest */
			gateway->close_pc(session->handle);
			#endif // stop
		} else {
			JANUS_LOG(LOG_VERB, "Unknown request '%s'\n", request_text);
			error_code = JANUS_RTPBROADCAST_ERROR_INVALID_REQUEST;
			g_snprintf(error_cause, 512, "Unknown request '%s'", request_text);
			goto error;
		}

		/* Any SDP to handle? */
		if(msg->sdp) {
			JANUS_LOG(LOG_VERB, "This is involving a negotiation (%s) as well (but we really don't care):\n%s\n", msg->sdp_type, msg->sdp);
		}

		/* Prepare JSON event */
		json_t *event = json_object();
		json_object_set_new(event, "streaming", json_string("event"));
		if(result != NULL)
			json_object_set_new(event, "result", result);
		char *event_text = json_dumps(event, JSON_INDENT(3) | JSON_PRESERVE_ORDER);
		json_decref(event);
		JANUS_LOG(LOG_VERB, "Pushing event: %s\n", event_text);
		int ret = gateway->push_event(msg->handle, &janus_rtpbroadcast_plugin, msg->transaction, event_text, sdp_type, sdp);
		JANUS_LOG(LOG_VERB, "  >> %d (%s)\n", ret, janus_get_api_error(ret));
		g_free(event_text);
		if(sdp)
			g_free(sdp);
		janus_rtpbroadcast_message_free(msg);
		continue;

error:
		{
			/* Prepare JSON error event */
			json_t *event = json_object();
			json_object_set_new(event, "streaming", json_string("event"));
			json_object_set_new(event, "error_code", json_integer(error_code));
			json_object_set_new(event, "error", json_string(error_cause));
			char *event_text = json_dumps(event, JSON_INDENT(3) | JSON_PRESERVE_ORDER);
			json_decref(event);
			JANUS_LOG(LOG_VERB, "Pushing event: %s\n", event_text);
			int ret = gateway->push_event(msg->handle, &janus_rtpbroadcast_plugin, msg->transaction, event_text, NULL, NULL);
			JANUS_LOG(LOG_VERB, "  >> %d (%s)\n", ret, janus_get_api_error(ret));
			g_free(event_text);
			janus_rtpbroadcast_message_free(msg);
		}
	}
	g_free(error_cause);
	JANUS_LOG(LOG_VERB, "Leaving Streaming handler thread\n");
	return NULL;
}

/* Helpers to create a listener filedescriptor */
static int janus_rtpbroadcast_create_fd(int port, in_addr_t mcast, const char* listenername, const char* medianame, const char* mountpointname) {
	struct sockaddr_in address;
	int fd = socket(AF_INET, SOCK_DGRAM, 0);
	if(fd < 0) {
		JANUS_LOG(LOG_ERR, "[%s] Cannot create socket for %s...\n", mountpointname, medianame);
		return -1;
	}
	if(port > 0) {
		int yes = 1;	/* For setsockopt() SO_REUSEADDR */
		setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(int));

		if(IN_MULTICAST(ntohl(mcast))) {
#ifdef IP_MULTICAST_ALL
			int mc_all = 0;
			if((setsockopt(fd, IPPROTO_IP, IP_MULTICAST_ALL, (void*) &mc_all, sizeof(mc_all))) < 0) {
				JANUS_LOG(LOG_ERR, "[%s] %s listener setsockopt IP_MULTICAST_ALL failed\n", mountpointname, listenername);
				close(fd);
				return -1;
			}
#endif
			struct ip_mreq mreq;
			memset(&mreq, 0, sizeof(mreq));
			mreq.imr_multiaddr.s_addr = mcast;
			if(setsockopt(fd, IPPROTO_IP, IP_ADD_MEMBERSHIP, &mreq, sizeof(struct ip_mreq)) == -1) {
				JANUS_LOG(LOG_ERR, "[%s] %s listener IP_ADD_MEMBERSHIP failed\n", mountpointname, listenername);
				close(fd);
				return -1;
			}
			JANUS_LOG(LOG_ERR, "[%s] %s listener IP_ADD_MEMBERSHIP ok\n", mountpointname, listenername);
		}
	}

	address.sin_family = AF_INET;
	address.sin_port = htons(port);
	address.sin_addr.s_addr = INADDR_ANY;
	if(bind(fd, (struct sockaddr *)(&address), sizeof(struct sockaddr)) < 0) {
		JANUS_LOG(LOG_ERR, "[%s] Bind failed for %s (port %d)...\n", mountpointname, medianame, port);
		close(fd);
		return -1;
	}
	return fd;
}

/* Helpers to destroy a streaming mountpoint. */
static void janus_rtpbroadcast_rtp_source_free(gpointer src) {
	janus_rtpbroadcast_rtp_source *source = *((janus_rtpbroadcast_rtp_source **)src);

	size_t j;
	for (j = AUDIO; j <= VIDEO; j++) {
		if(source->fd[j] > 0) {
			close(source->fd[j]);
		}
		g_free(source->codecs.rtpmap[j]);
		g_free(source->codecs.fmtp[j]);

		/* Remove ports from used ports */
		janus_rtpbroadcast_port_manager_free(source->port[j]);
	}

	g_free(source);
}

static void janus_rtpbroadcast_mountpoint_free(janus_rtpbroadcast_mountpoint *mp) {
	mp->destroyed = janus_get_monotonic_time();

	g_free(mp->id);
	g_free(mp->name);
	g_free(mp->description);
	janus_mutex_lock(&mp->mutex);
	g_list_free(mp->listeners);
	janus_mutex_unlock(&mp->mutex);

	if (mp->sources) /* TODO: @landswellsong: see if this correctly deallocates everything */
		g_array_free(mp->sources, TRUE);

	g_free(mp);
}

/* Helper to create an RTP live source (e.g., from gstreamer/ffmpeg/vlc/etc.) */
janus_rtpbroadcast_mountpoint *janus_rtpbroadcast_create_rtp_source(
		char *id, char *name, char *desc,
		GArray *requests) {
	if(name == NULL) {
		JANUS_LOG(LOG_VERB, "Missing name, will generate a random one...\n");
	}
	janus_rtpbroadcast_mountpoint *live_rtp = g_malloc0(sizeof(janus_rtpbroadcast_mountpoint));
	if(live_rtp == NULL) {
		JANUS_LOG(LOG_FATAL, "Memory error!\n");
		return NULL;
	}
	live_rtp->id = g_strdup(id);
	char tempname[255];
	if(!name) {
		memset(tempname, 0, 255);
		g_snprintf(tempname, 255, "%s", live_rtp->id);
	}
	live_rtp->name = g_strdup(name ? name : tempname);
	live_rtp->description = g_strdup(desc != NULL ? desc : (name ? name : tempname));
	live_rtp->enabled = TRUE;

	live_rtp->rc[AUDIO] = NULL;
	live_rtp->rc[VIDEO] = NULL;

	/* Iterating over requests array to add all streams */
	live_rtp->sources = g_array_sized_new(FALSE, FALSE, sizeof(janus_rtpbroadcast_rtp_source*), requests->len);
	g_array_set_clear_func(live_rtp->sources, (GDestroyNotify) janus_rtpbroadcast_rtp_source_free);
	guint i,j;
	for (i = 0; i < requests->len; i++) {
		janus_rtpbroadcast_rtp_source_request req = g_array_index(requests, janus_rtpbroadcast_rtp_source_request, i);
		janus_rtpbroadcast_rtp_source *live_rtp_source = g_malloc0(sizeof(janus_rtpbroadcast_rtp_source));

		if(live_rtp_source == NULL) {
			JANUS_LOG(LOG_FATAL, "Memory error!\n");
			goto error;
		}

		live_rtp_source->parent = live_rtp;
		janus_mutex_init(&live_rtp_source->stats.stat_mutex);
		memset(&live_rtp_source->stats, 0, sizeof(live_rtp_source->stats));

		for (j = AUDIO; j <= VIDEO; j++) {
			live_rtp_source->mcast[j] = req.mcast[j] ? inet_addr(req.mcast[j]) : INADDR_ANY;
			live_rtp_source->fd[j] = -1;
			live_rtp_source->codecs.pt[j] = req.codec[j];
			live_rtp_source->codecs.rtpmap[j] = req.rtpmap[j] ? g_strdup(req.rtpmap[j]) : NULL;
			live_rtp_source->codecs.fmtp[j] = req.fmtp[j] ? g_strdup(req.fmtp[j]) : NULL;

			/* Checking the next valid port */
			/* TODO @landswellsong: hash table only remembers the source, do we need it
							to remember whether it was video or audio too? */
			live_rtp_source->port[j] = janus_rtpbroadcast_port_manager_assign(live_rtp_source);
		}
		g_array_append_val(live_rtp->sources, live_rtp_source);
	}

	live_rtp->listeners = NULL;
	live_rtp->destroyed = 0;
	janus_mutex_init(&live_rtp->mutex);
	for (i = 0; i < live_rtp->sources->len; i++) {
		char tempname[256];
		memset(tempname, 0, 255);
		g_snprintf(tempname, 255, "%s %d", live_rtp->id, i);

		GError *error = NULL;
		janus_rtpbroadcast_rtp_relay_thread_data *dt = g_malloc0(sizeof(janus_rtpbroadcast_rtp_relay_thread_data)); /* Memory fred within */
		dt->mp = live_rtp;
		dt->i = i;
		g_thread_try_new(tempname, &janus_rtpbroadcast_relay_thread, dt, &error);
		if(error != NULL) {
			JANUS_LOG(LOG_ERR, "Got error %d (%s) trying to launch the RTP thread...\n", error->code, error->message ? error->message : "??");
			goto error;
		}
	}
	janus_mutex_lock(&mountpoints_mutex);
	g_hash_table_insert(mountpoints, g_strdup(live_rtp->id), live_rtp);
	janus_mutex_unlock(&mountpoints_mutex);
	return live_rtp;

	error:
	g_free(live_rtp->id);
	g_free(live_rtp->name);
	g_free(live_rtp->description);
	g_array_free(live_rtp->sources, TRUE);
	return NULL;
}

/* FIXME Test thread to relay RTP frames coming from gstreamer/ffmpeg/others */
static void *janus_rtpbroadcast_relay_thread(void *data) {
	JANUS_LOG(LOG_VERB, "Starting streaming relay thread\n");
	janus_rtpbroadcast_rtp_relay_thread_data *tdata = (janus_rtpbroadcast_rtp_relay_thread_data *)data;
	janus_rtpbroadcast_mountpoint *mountpoint = tdata->mp;
	guint nstream = tdata->i;
	janus_rtpbroadcast_rtp_source *source = g_array_index(mountpoint->sources, janus_rtpbroadcast_rtp_source*, nstream);
  /* Data no longer needed */
	g_free(data);

	if(!mountpoint) {
		JANUS_LOG(LOG_ERR, "Invalid mountpoint!\n");
		g_thread_unref(g_thread_self());
		return NULL;
	}
	if(source == NULL) {
		JANUS_LOG(LOG_ERR, "[%s] Invalid RTP source mountpoint!\n", mountpoint->name);
		g_thread_unref(g_thread_self());
		return NULL;
	}

	size_t j;
	for (j = AUDIO; j <= VIDEO; j++) {
		static const char *lnames[] = { "Audio", "Video" };
		/* Socket stuff */
		if((source->fd[j] < 0) && (source->port[j] >= 0)) {
			source->fd[j] = janus_rtpbroadcast_create_fd(source->port[j], source->mcast[j], lnames[j], av_names[j], mountpoint->name);
			if(source->fd[j] < 0) {
				g_thread_unref(g_thread_self());
				return NULL;
			}
			JANUS_LOG(LOG_VERB, "[%s] %s listener bound to port %d\n", lnames[j], mountpoint->name, source->port[j]);
		}
	}

	char *name = g_strdup(mountpoint->name ? mountpoint->name : "??");
	/* Needed to fix seq and ts */
	janus_rtpbroadcast_context ctx;
	memset(&ctx, 0, sizeof(ctx));

	/* Loop */
	socklen_t addrlen;
	struct sockaddr_in remote;
	int resfd = 0, bytes = 0;
	struct pollfd fds[2];
	char buffer[1500];
	memset(buffer, 0, 1500);
	janus_rtpbroadcast_rtp_relay_packet packet;

	while(!g_atomic_int_get(&stopping) && !mountpoint->destroyed) {
		/* Wait for some data */
		for (j = AUDIO; j <= VIDEO; j++) {
			fds[j].fd = 0;
			fds[j].events = 0;
			fds[j].revents = 0;
			if(source->fd[j] > 0) {
				fds[j].fd = source->fd[j];
				fds[j].events = POLLIN;
			}
		}

		resfd = poll(fds, 2, 1000);
		if(resfd < 0) {
			JANUS_LOG(LOG_ERR, "[%s] Error polling... %d (%s)\n", mountpoint->name, errno, strerror(errno));
			break;
		} else if(resfd == 0) {
			janus_rtpbroadcast_stats_update(&source->stats, 0);
			/* No data, keep going */
			continue;
		}

		for (j = AUDIO; j <= VIDEO; j++) {
			if(source->fd[j] && (fds[j].revents & POLLIN)) {
				/* Got something (RTP) */
				fds[j].revents = 0;
				if(source->active == FALSE) {
					source->active = TRUE;
					/* After inactivity we reset stats */
					janus_rtpbroadcast_stats_restart(&source->stats);
				}
				addrlen = sizeof(remote);
				bytes = recvfrom(source->fd[j], buffer, 1500, 0, (struct sockaddr*)&remote, &addrlen);
				/* FIXME @landswellsong are we only expecting IPv4 ? */
				janus_rtpbroadcast_stats_update(&source->stats, bytes + sizeof(struct ip) + sizeof(struct udphdr));
				//~ JANUS_LOG(LOG_VERB, "************************\nGot %d bytes on the %і channel...\n", av_names[j], bytes);
				/* If paused, ignore this packet */
				if(!mountpoint->enabled)
					continue;
				rtp_header *rtp = (rtp_header *)buffer;
				//~ JANUS_LOG(LOG_VERB, " ... parsed RTP packet (ssrc=%u, pt=%u, seq=%u, ts=%u)...\n",
					//~ ntohl(rtp->ssrc), rtp->type, ntohs(rtp->seq_number), ntohl(rtp->timestamp));
				/* Relay on all sessions */
				packet.data = rtp;
				packet.length = bytes;
				packet.is_video = (j == VIDEO);
				/* Do we have a new stream? */
				if(ntohl(packet.data->ssrc) != ctx.last_ssrc[j]) {
					ctx.last_ssrc[j] = ntohl(packet.data->ssrc);
					JANUS_LOG(LOG_INFO, "[%s] New %s stream! (ssrc=%u)\n", name, av_names[j], ctx.last_ssrc[j]);
					ctx.base_ts_prev[j] = ctx.last_ts[j];
					ctx.base_ts[j] = ntohl(packet.data->timestamp);
					ctx.base_seq_prev[j] = ctx.last_seq[j];
					ctx.base_seq[j] = ntohs(packet.data->seq_number);
				}
				/* FIXME We're assuming Opus here for audio and 15fps for video... */
				ctx.last_ts[j] = (ntohl(packet.data->timestamp)-ctx.base_ts[j])+ctx.base_ts_prev[j]+ (j == AUDIO? 960 : 4500);
				packet.data->timestamp = htonl(ctx.last_ts[j]);
				ctx.last_seq[j] = (ntohs(packet.data->seq_number)-ctx.base_seq[j])+ctx.base_seq_prev[j]+1;
				packet.data->seq_number = htons(ctx.last_seq[j]);
				//~ JANUS_LOG(LOG_VERB, " ... updated RTP packet (ssrc=%u, pt=%u, seq=%u, ts=%u)...\n",
					//~ ntohl(rtp->ssrc), rtp->type, ntohs(rtp->seq_number), ntohl(rtp->timestamp));
				packet.data->type = source->codecs.pt[j];
				/* Is there a recorder? */
				if(mountpoint->rc[j]) {
					JANUS_LOG(LOG_HUGE, "[%s] Saving %s frame (%d bytes)\n", name, av_names[j], bytes);
					janus_recorder_save_frame(mountpoint->rc[j], buffer, bytes);
				}
				/* Backup the actual timestamp and sequence number set by the restreamer, in case switching is involved */
				packet.timestamp = ntohl(packet.data->timestamp);
				packet.seq_number = ntohs(packet.data->seq_number);
				/* Go! */
				janus_mutex_lock(&mountpoint->mutex);
				/* FIXME: @landswellsong for now only first stream is active */
				if (nstream == 0)
				g_list_foreach(mountpoint->listeners, janus_rtpbroadcast_relay_rtp_packet, &packet);
				janus_mutex_unlock(&mountpoint->mutex);
				continue;
			}
		}
	}
	JANUS_LOG(LOG_VERB, "[%s] Leaving streaming relay thread\n", name);
	g_free(name);
	g_thread_unref(g_thread_self());
	return NULL;
}

static void janus_rtpbroadcast_relay_rtp_packet(gpointer data, gpointer user_data) {
	janus_rtpbroadcast_rtp_relay_packet *packet = (janus_rtpbroadcast_rtp_relay_packet *)user_data;
	if(!packet || !packet->data || packet->length < 1) {
		JANUS_LOG(LOG_ERR, "Invalid packet...\n");
		return;
	}
	janus_rtpbroadcast_session *session = (janus_rtpbroadcast_session *)data;
	if(!session || !session->handle) {
		//~ JANUS_LOG(LOG_ERR, "Invalid session...\n");
		return;
	}
	if(!session->started || session->paused) {
		//~ JANUS_LOG(LOG_ERR, "Streaming not started yet for this session...\n");
		return;
	}

	/* Make sure there hasn't been a publisher switch by checking the SSRC */
	size_t j = packet->is_video? VIDEO : AUDIO;
	if(ntohl(packet->data->ssrc) != session->context.last_ssrc[j]) {
		session->context.last_ssrc[j] = ntohl(packet->data->ssrc);
		session->context.base_ts_prev[j] = session->context.last_ts[j];
		session->context.base_ts[j] = packet->timestamp;
		session->context.base_seq_prev[j] = session->context.last_seq[j];
		session->context.base_seq[j] = packet->seq_number;
	}
	/* Compute a coherent timestamp and sequence number */
	/* FIXME When switching, we assume 15fps for video and Opus and so a 960 ts step for audio */
	session->context.last_ts[j] = (packet->timestamp-session->context.base_ts[j])
		+ session->context.base_ts_prev[j]+(packet->is_video? 4500 : 960);
	session->context.last_seq[j] = (packet->seq_number-session->context.base_seq[j])+session->context.base_seq_prev[j]+1;
	/* Update the timestamp and sequence number in the RTP packet, and send it */
	packet->data->timestamp = htonl(session->context.last_ts[j]);
	packet->data->seq_number = htons(session->context.last_seq[j]);
	if(gateway != NULL)
		gateway->relay_rtp(session->handle, packet->is_video, (char *)packet->data, packet->length);
	/* Restore the timestamp and sequence number to what the publisher set them to */
	packet->data->timestamp = htonl(packet->timestamp);
	packet->data->seq_number = htons(packet->seq_number);
	return;
}

void janus_rtpbroadcast_port_manager_init(guint minport, guint maxport) {
	port_manager.used_ports = g_hash_table_new(NULL, NULL);
	janus_mutex_init(&port_manager.used_ports_mutex);

	/* Generating random sequence of ports */
	GList *straight = NULL;
	guint i;
	for (i = minport; i <= maxport; i++)
		straight = g_list_prepend(straight, GUINT_TO_POINTER(i));
	guint len = port_manager.ports_available = maxport - minport + 1;

	while (len > 0) {
		GList *el = g_list_nth(straight, random() % (len--));
		port_manager.free_ports = g_list_prepend(port_manager.free_ports, GUINT_TO_POINTER(el->data));
		straight = g_list_delete_link(straight, el);
	}

	/* Shouldn't happen but just in case */
	if (straight)
		g_list_free(straight);
}

guint janus_rtpbroadcast_port_manager_assign(gpointer src) {
	janus_mutex_lock(&port_manager.used_ports_mutex);

	/* Inserting the new port to hash table and removing from the list */
	guint res = GPOINTER_TO_UINT(port_manager.free_ports->data);
	port_manager.free_ports = g_list_delete_link(port_manager.free_ports, port_manager.free_ports);
	g_hash_table_insert(port_manager.used_ports, GUINT_TO_POINTER(res), src);

	port_manager.ports_available--;

	janus_mutex_unlock(&port_manager.used_ports_mutex);
	return res;
}

void janus_rtpbroadcast_port_manager_free(guint port) {
	janus_mutex_lock(&port_manager.used_ports_mutex);

	/* Removing the port from the hash table and inserting to the list */
	g_hash_table_remove(port_manager.used_ports, GUINT_TO_POINTER(port));
	port_manager.free_ports = g_list_insert_before(port_manager.free_ports,
	 	g_list_nth(port_manager.free_ports, port_manager.ports_available), GUINT_TO_POINTER(port));

	port_manager.ports_available++;

	janus_mutex_unlock(&port_manager.used_ports_mutex);
}

void janus_rtpbroadcast_port_manager_destroy() {
	janus_mutex_lock(&port_manager.used_ports_mutex);

	g_hash_table_destroy(port_manager.used_ports);
	g_list_free(port_manager.free_ports);
	port_manager.ports_available = 0;

	janus_mutex_unlock(&port_manager.used_ports_mutex);
}

static void janus_rtpbroadcast_stats_restart(janus_rtpbroadcast_stats *st) {
	janus_mutex_lock(&st->stat_mutex);

	memset(st, 0, sizeof(*st));
	guint64 ml = janus_get_monotonic_time();
	st->start_usec = ml;
	st->last_avg_usec = ml;

	janus_mutex_unlock(&st->stat_mutex);
}

static void janus_rtpbroadcast_stats_update(janus_rtpbroadcast_stats *st, int bytes) {
	janus_mutex_lock(&st->stat_mutex);

	/* This overflows at 17179869184 GB of traffic just in case :) */
	st->bytes_since_start += bytes;
	st->bytes_since_last_avg += bytes;

	guint64 ml = janus_get_monotonic_time();

	/* If we step over delay, calculate current and compare min/max */
	if (ml - st->last_avg_usec >= STAT_UPDATE_DELAY) {
		st->cur = (8.0L*10e6L)*(gdouble)st->bytes_since_last_avg / (ml - st->last_avg_usec);
		if (st->cur > st->max)
			st->max = st->cur;
		if (st->cur < st->min || st->min == 0.0L)
			st->min = st->cur;

		st->bytes_since_last_avg = 0;
		st->last_avg_usec = ml;
	}

	/* Re-calculate average regardless */
	st->avg = (8.0L*10e6L)*(gdouble)st->bytes_since_start / (ml - st->start_usec);

	janus_mutex_unlock(&st->stat_mutex);
}
